#include <riscv_vector.h>
#include <stddef.h>
#include <stdio.h>
#include <math.h>

#define N 31

float inputA[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30};
float inputB[N] = {30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0};
float output_golden[N] = {
    1.7491401329284098,  0.1325982188803279,  0.3252281811989881,
    -0.7938091410349637, 0.3149236145048914,  -0.5272704888029532,
    0.9322666565031119,  1.1646643544607362,  -2.0456694357357357,
    -0.6443728590041911, 1.7410657940825480,  0.4867684246821860,
    1.0488288293660140,  1.4885752747099299,  1.2705014969484090,
    -1.8561241921210170, 2.1343209047321410,  1.4358467535865909,
    -0.9173023332875400, -1.1060770780029008, 0.8105708062681296,
    0.6985430696369063,  -0.4015827425012831, 1.2687512030669628,
    -0.7836083053674872, 0.2132664971465569,  0.7878984786088954,
    0.8966819356782295,  -0.1869172943544062, 1.0131816724341454,
    0.2484350696132857};

float output[N] = {
    1.7491401329284098,  0.1325982188803279,  0.3252281811989881,
    -0.7938091410349637, 0.3149236145048914,  -0.5272704888029532,
    0.9322666565031119,  1.1646643544607362,  -2.0456694357357357,
    -0.6443728590041911, 1.7410657940825480,  0.4867684246821860,
    1.0488288293660140,  1.4885752747099299,  1.2705014969484090,
    -1.8561241921210170, 2.1343209047321410,  1.4358467535865909,
    -0.9173023332875400, -1.1060770780029008, 0.8105708062681296,
    0.6985430696369063,  -0.4015827425012831, 1.2687512030669628,
    -0.7836083053674872, 0.2132664971465569,  0.7878984786088954,
    0.8966819356782295,  -0.1869172943544062, 1.0131816724341454,
    0.2484350696132857};

void cross_golden(size_t n, const float *x1, const float *x2, float *y) {
  for (size_t i = 0; i < n; ++i) {
        if(i%4 == 0)
            y[i] = x1[i + 2] * x2[i + 1] - x1[i + 1]*x2[i + 2];
        if(i%4 == 1)
            y[i] = x1[i - 1] * x2[i + 1] - x1[i + 1]*x2[i - 1];
        if(i%4 == 2)
            y[i] = x1[i - 1] * x2[i - 2] - x1[i - 2]*x2[i - 1];
        if(i%4 == 3)
            y[i] = x2[i] - x1[i];
  }
}


void cross_vec(size_t n, const float *x1, const float *x2, float *y) {
  size_t l;

  vfloat32m1_t vx1, vx2, vy;

  l = __riscv_vsetvl_e32m1(n);
  for (; n > 0; n -= l) {
    l = __riscv_vsetvl_e32m1(n);
    vx1 = __riscv_vle32_v_f32m1(x1, l);
    x1 += l;
    vx2 = __riscv_vle32_v_f32m1(x2, l);
    x2 += l;
    vy = __riscv_vle32_v_f32m1(y, l);
    vy = __riscv_vfcross_vv_f32m1(vx1, vx2, l);
    __riscv_vse32_v_f32m1 (y, vy, l);
    y += l;
  }
}

int fp_eq(float reference, float actual, float relErr)
{
  // if near zero, do absolute error instead.
  float absErr = relErr * ((fabsf(reference) > relErr) ? fabsf(reference) : relErr);
  return fabsf(actual - reference) < absErr;
}


int main() {
  cross_golden(N, inputA, inputB, output_golden);
  cross_vec(N, inputA, inputB, output);
  int pass = 1;
  for (int i = 0; i < N; i++) {
    if (!fp_eq(output_golden[i], output[i], 1e-6)) {
      printf("failed, [%i]=%f=!%f\n", i, output_golden[i], output[i]);
      pass = 0;
    }
  }
  if (pass)
    printf("passed\n");
  return (pass == 0);
}
